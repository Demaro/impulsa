{"remainingRequest":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\chart.js\\src\\core\\core.animations.js","dependencies":[{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\chart.js\\src\\core\\core.animations.js","mtime":1547494845846},{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1547494841080},{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1547494719834}],"contextDependencies":[],"result":["/* global window: false */\r\n'use strict';\r\n\r\nvar defaults = require('./core.defaults');\r\nvar helpers = require('../helpers/index');\r\n\r\ndefaults._set('global', {\r\n\tanimation: {\r\n\t\tduration: 1000,\r\n\t\teasing: 'easeOutQuart',\r\n\t\tonProgress: helpers.noop,\r\n\t\tonComplete: helpers.noop\r\n\t}\r\n});\r\n\r\nmodule.exports = {\r\n\tframeDuration: 17,\r\n\tanimations: [],\r\n\tdropFrames: 0,\r\n\trequest: null,\r\n\r\n\t/**\r\n\t * @param {Chart} chart - The chart to animate.\r\n\t * @param {Chart.Animation} animation - The animation that we will animate.\r\n\t * @param {Number} duration - The animation duration in ms.\r\n\t * @param {Boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions\r\n\t */\r\n\taddAnimation: function(chart, animation, duration, lazy) {\r\n\t\tvar animations = this.animations;\r\n\t\tvar i, ilen;\r\n\r\n\t\tanimation.chart = chart;\r\n\r\n\t\tif (!lazy) {\r\n\t\t\tchart.animating = true;\r\n\t\t}\r\n\r\n\t\tfor (i = 0, ilen = animations.length; i < ilen; ++i) {\r\n\t\t\tif (animations[i].chart === chart) {\r\n\t\t\t\tanimations[i] = animation;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tanimations.push(animation);\r\n\r\n\t\t// If there are no animations queued, manually kickstart a digest, for lack of a better word\r\n\t\tif (animations.length === 1) {\r\n\t\t\tthis.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\tcancelAnimation: function(chart) {\r\n\t\tvar index = helpers.findIndex(this.animations, function(animation) {\r\n\t\t\treturn animation.chart === chart;\r\n\t\t});\r\n\r\n\t\tif (index !== -1) {\r\n\t\t\tthis.animations.splice(index, 1);\r\n\t\t\tchart.animating = false;\r\n\t\t}\r\n\t},\r\n\r\n\trequestAnimationFrame: function() {\r\n\t\tvar me = this;\r\n\t\tif (me.request === null) {\r\n\t\t\t// Skip animation frame requests until the active one is executed.\r\n\t\t\t// This can happen when processing mouse events, e.g. 'mousemove'\r\n\t\t\t// and 'mouseout' events will trigger multiple renders.\r\n\t\t\tme.request = helpers.requestAnimFrame.call(window, function() {\r\n\t\t\t\tme.request = null;\r\n\t\t\t\tme.startDigest();\r\n\t\t\t});\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tstartDigest: function() {\r\n\t\tvar me = this;\r\n\t\tvar startTime = Date.now();\r\n\t\tvar framesToDrop = 0;\r\n\r\n\t\tif (me.dropFrames > 1) {\r\n\t\t\tframesToDrop = Math.floor(me.dropFrames);\r\n\t\t\tme.dropFrames = me.dropFrames % 1;\r\n\t\t}\r\n\r\n\t\tme.advance(1 + framesToDrop);\r\n\r\n\t\tvar endTime = Date.now();\r\n\r\n\t\tme.dropFrames += (endTime - startTime) / me.frameDuration;\r\n\r\n\t\t// Do we have more stuff to animate?\r\n\t\tif (me.animations.length > 0) {\r\n\t\t\tme.requestAnimationFrame();\r\n\t\t}\r\n\t},\r\n\r\n\t/**\r\n\t * @private\r\n\t */\r\n\tadvance: function(count) {\r\n\t\tvar animations = this.animations;\r\n\t\tvar animation, chart;\r\n\t\tvar i = 0;\r\n\r\n\t\twhile (i < animations.length) {\r\n\t\t\tanimation = animations[i];\r\n\t\t\tchart = animation.chart;\r\n\r\n\t\t\tanimation.currentStep = (animation.currentStep || 0) + count;\r\n\t\t\tanimation.currentStep = Math.min(animation.currentStep, animation.numSteps);\r\n\r\n\t\t\thelpers.callback(animation.render, [chart, animation], chart);\r\n\t\t\thelpers.callback(animation.onAnimationProgress, [animation], chart);\r\n\r\n\t\t\tif (animation.currentStep >= animation.numSteps) {\r\n\t\t\t\thelpers.callback(animation.onAnimationComplete, [animation], chart);\r\n\t\t\t\tchart.animating = false;\r\n\t\t\t\tanimations.splice(i, 1);\r\n\t\t\t} else {\r\n\t\t\t\t++i;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n",null]}