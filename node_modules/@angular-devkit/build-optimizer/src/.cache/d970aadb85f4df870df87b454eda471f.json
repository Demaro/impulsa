{"remainingRequest":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\chart.js\\src\\helpers\\helpers.canvas.js","dependencies":[{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\chart.js\\src\\helpers\\helpers.canvas.js","mtime":1547494845896},{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1547494841080},{"path":"C:\\Users\\dmartinez\\Documents\\portafolio\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1547494719834}],"contextDependencies":[],"result":["'use strict';\r\n\r\nvar helpers = require('./helpers.core');\r\n\r\n/**\r\n * @namespace Chart.helpers.canvas\r\n */\r\nvar exports = module.exports = {\r\n\t/**\r\n\t * Clears the entire canvas associated to the given `chart`.\r\n\t * @param {Chart} chart - The chart for which to clear the canvas.\r\n\t */\r\n\tclear: function(chart) {\r\n\t\tchart.ctx.clearRect(0, 0, chart.width, chart.height);\r\n\t},\r\n\r\n\t/**\r\n\t * Creates a \"path\" for a rectangle with rounded corners at position (x, y) with a\r\n\t * given size (width, height) and the same `radius` for all corners.\r\n\t * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.\r\n\t * @param {Number} x - The x axis of the coordinate for the rectangle starting point.\r\n\t * @param {Number} y - The y axis of the coordinate for the rectangle starting point.\r\n\t * @param {Number} width - The rectangle's width.\r\n\t * @param {Number} height - The rectangle's height.\r\n\t * @param {Number} radius - The rounded amount (in pixels) for the four corners.\r\n\t * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?\r\n\t */\r\n\troundedRect: function(ctx, x, y, width, height, radius) {\r\n\t\tif (radius) {\r\n\t\t\t// NOTE(SB) `epsilon` helps to prevent minor artifacts appearing\r\n\t\t\t// on Chrome when `r` is exactly half the height or the width.\r\n\t\t\tvar epsilon = 0.0000001;\r\n\t\t\tvar r = Math.min(radius, (height / 2) - epsilon, (width / 2) - epsilon);\r\n\r\n\t\t\tctx.moveTo(x + r, y);\r\n\t\t\tctx.lineTo(x + width - r, y);\r\n\t\t\tctx.arcTo(x + width, y, x + width, y + r, r);\r\n\t\t\tctx.lineTo(x + width, y + height - r);\r\n\t\t\tctx.arcTo(x + width, y + height, x + width - r, y + height, r);\r\n\t\t\tctx.lineTo(x + r, y + height);\r\n\t\t\tctx.arcTo(x, y + height, x, y + height - r, r);\r\n\t\t\tctx.lineTo(x, y + r);\r\n\t\t\tctx.arcTo(x, y, x + r, y, r);\r\n\t\t\tctx.closePath();\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t} else {\r\n\t\t\tctx.rect(x, y, width, height);\r\n\t\t}\r\n\t},\r\n\r\n\tdrawPoint: function(ctx, style, radius, x, y, rotation) {\r\n\t\tvar type, edgeLength, xOffset, yOffset, height, size;\r\n\t\trotation = rotation || 0;\r\n\r\n\t\tif (style && typeof style === 'object') {\r\n\t\t\ttype = style.toString();\r\n\t\t\tif (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\r\n\t\t\t\tctx.drawImage(style, x - style.width / 2, y - style.height / 2, style.width, style.height);\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (isNaN(radius) || radius <= 0) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.save();\r\n\t\tctx.translate(x, y);\r\n\t\tctx.rotate(rotation * Math.PI / 180);\r\n\t\tctx.beginPath();\r\n\r\n\t\tswitch (style) {\r\n\t\t// Default includes circle\r\n\t\tdefault:\r\n\t\t\tctx.arc(0, 0, radius, 0, Math.PI * 2);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'triangle':\r\n\t\t\tedgeLength = 3 * radius / Math.sqrt(3);\r\n\t\t\theight = edgeLength * Math.sqrt(3) / 2;\r\n\t\t\tctx.moveTo(-edgeLength / 2, height / 3);\r\n\t\t\tctx.lineTo(edgeLength / 2, height / 3);\r\n\t\t\tctx.lineTo(0, -2 * height / 3);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'rect':\r\n\t\t\tsize = 1 / Math.SQRT2 * radius;\r\n\t\t\tctx.rect(-size, -size, 2 * size, 2 * size);\r\n\t\t\tbreak;\r\n\t\tcase 'rectRounded':\r\n\t\t\tvar offset = radius / Math.SQRT2;\r\n\t\t\tvar leftX = -offset;\r\n\t\t\tvar topY = -offset;\r\n\t\t\tvar sideSize = Math.SQRT2 * radius;\r\n\r\n\t\t\t// NOTE(SB) the rounded rect implementation changed to use `arcTo`\r\n\t\t\t// instead of `quadraticCurveTo` since it generates better results\r\n\t\t\t// when rect is almost a circle. 0.425 (instead of 0.5) produces\r\n\t\t\t// results visually closer to the previous impl.\r\n\t\t\tthis.roundedRect(ctx, leftX, topY, sideSize, sideSize, radius * 0.425);\r\n\t\t\tbreak;\r\n\t\tcase 'rectRot':\r\n\t\t\tsize = 1 / Math.SQRT2 * radius;\r\n\t\t\tctx.moveTo(-size, 0);\r\n\t\t\tctx.lineTo(0, size);\r\n\t\t\tctx.lineTo(size, 0);\r\n\t\t\tctx.lineTo(0, -size);\r\n\t\t\tctx.closePath();\r\n\t\t\tbreak;\r\n\t\tcase 'cross':\r\n\t\t\tctx.moveTo(0, radius);\r\n\t\t\tctx.lineTo(0, -radius);\r\n\t\t\tctx.moveTo(-radius, 0);\r\n\t\t\tctx.lineTo(radius, 0);\r\n\t\t\tbreak;\r\n\t\tcase 'crossRot':\r\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\r\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\r\n\t\t\tctx.moveTo(-xOffset, -yOffset);\r\n\t\t\tctx.lineTo(xOffset, yOffset);\r\n\t\t\tctx.moveTo(-xOffset, yOffset);\r\n\t\t\tctx.lineTo(xOffset, -yOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'star':\r\n\t\t\tctx.moveTo(0, radius);\r\n\t\t\tctx.lineTo(0, -radius);\r\n\t\t\tctx.moveTo(-radius, 0);\r\n\t\t\tctx.lineTo(radius, 0);\r\n\t\t\txOffset = Math.cos(Math.PI / 4) * radius;\r\n\t\t\tyOffset = Math.sin(Math.PI / 4) * radius;\r\n\t\t\tctx.moveTo(-xOffset, -yOffset);\r\n\t\t\tctx.lineTo(xOffset, yOffset);\r\n\t\t\tctx.moveTo(-xOffset, yOffset);\r\n\t\t\tctx.lineTo(xOffset, -yOffset);\r\n\t\t\tbreak;\r\n\t\tcase 'line':\r\n\t\t\tctx.moveTo(-radius, 0);\r\n\t\t\tctx.lineTo(radius, 0);\r\n\t\t\tbreak;\r\n\t\tcase 'dash':\r\n\t\t\tctx.moveTo(0, 0);\r\n\t\t\tctx.lineTo(radius, 0);\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tctx.fill();\r\n\t\tctx.stroke();\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tclipArea: function(ctx, area) {\r\n\t\tctx.save();\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\r\n\t\tctx.clip();\r\n\t},\r\n\r\n\tunclipArea: function(ctx) {\r\n\t\tctx.restore();\r\n\t},\r\n\r\n\tlineTo: function(ctx, previous, target, flip) {\r\n\t\tif (target.steppedLine) {\r\n\t\t\tif ((target.steppedLine === 'after' && !flip) || (target.steppedLine !== 'after' && flip)) {\r\n\t\t\t\tctx.lineTo(previous.x, target.y);\r\n\t\t\t} else {\r\n\t\t\t\tctx.lineTo(target.x, previous.y);\r\n\t\t\t}\r\n\t\t\tctx.lineTo(target.x, target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tif (!target.tension) {\r\n\t\t\tctx.lineTo(target.x, target.y);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tctx.bezierCurveTo(\r\n\t\t\tflip ? previous.controlPointPreviousX : previous.controlPointNextX,\r\n\t\t\tflip ? previous.controlPointPreviousY : previous.controlPointNextY,\r\n\t\t\tflip ? target.controlPointNextX : target.controlPointPreviousX,\r\n\t\t\tflip ? target.controlPointNextY : target.controlPointPreviousY,\r\n\t\t\ttarget.x,\r\n\t\t\ttarget.y);\r\n\t}\r\n};\r\n\r\n// DEPRECATIONS\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.\r\n * @namespace Chart.helpers.clear\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.clear = exports.clear;\r\n\r\n/**\r\n * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.\r\n * @namespace Chart.helpers.drawRoundedRectangle\r\n * @deprecated since version 2.7.0\r\n * @todo remove at version 3\r\n * @private\r\n */\r\nhelpers.drawRoundedRectangle = function(ctx) {\r\n\tctx.beginPath();\r\n\texports.roundedRect.apply(exports, arguments);\r\n};\r\n",null]}